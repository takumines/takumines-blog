---
description: 
globs: "**/*.tsx", "app/**/*.ts", "app/**/*.js"
alwaysApply: false
---
# React・Next.js規約

[next.config.mjs](mdc:next.config.mjs)の設定に基づくReact・Next.js開発ルールです。

## コンポーネント設計

### 関数コンポーネントの統一形式
```tsx
// アロー関数で統一
interface ArticleCardProps {
  article: ArticleMetadata
  onClick?: () => void
}

export const ArticleCard = ({ article, onClick }: ArticleCardProps) => {
  return (
    <article className="border rounded-lg p-4">
      <h2 className="text-xl font-bold">{article.title}</h2>
      <button onClick={onClick}>詳細を見る</button>
    </article>
  )
}
```

### カスタムフック
```tsx
// useプレフィックスで命名
export const useArticleData = (articleId: string) => {
  const [article, setArticle] = useState<Article | null>(null)
  const [loading, setLoading] = useState(true)
  
  useEffect(() => {
    fetchArticle(articleId).then(setArticle).finally(() => setLoading(false))
  }, [articleId])
  
  return { article, loading }
}
```

## App Router規約

### サーバーコンポーネント（デフォルト）
```tsx
// app/articles/page.tsx
export default async function ArticlesPage() {
  // サーバーサイドでデータ取得
  const articles = await fetchArticles()
  
  return (
    <div>
      {articles.map(article => (
        <ArticleCard key={article.id} article={article} />
      ))}
    </div>
  )
}
```

### クライアントコンポーネント（必要時のみ）
```tsx
"use client"

import { useState } from "react"

export const InteractiveButton = () => {
  const [count, setCount] = useState(0)
  
  return (
    <button onClick={() => setCount(count + 1)}>
      クリック数: {count}
    </button>
  )
}
```

### メタデータ設定
```tsx
// 静的メタデータ
export const metadata: Metadata = {
  title: "記事一覧",
  description: "Notionから取得した記事の一覧です"
}

// 動的メタデータ
export async function generateMetadata({ params }: { params: { id: string } }): Promise<Metadata> {
  const article = await fetchArticle(params.id)
  
  return {
    title: article.title,
    description: article.excerpt,
    openGraph: {
      title: article.title,
      description: article.excerpt,
      images: [article.coverImage]
    }
  }
}
```

## State管理

### 最小限のState
```tsx
// 必要最小限のstateのみ
export const ArticleForm = () => {
  const [title, setTitle] = useState("")
  const [isSubmitting, setIsSubmitting] = useState(false)
  
  // 派生状態は計算で求める
  const isValid = title.length > 0
  
  return (
    <form>
      <input 
        value={title} 
        onChange={(e) => setTitle(e.target.value)} 
      />
      <button disabled={!isValid || isSubmitting}>
        送信
      </button>
    </form>
  )
}
```

### useEffect依存配列
```tsx
export const ArticleDetail = ({ articleId }: { articleId: string }) => {
  const [article, setArticle] = useState<Article | null>(null)
  
  useEffect(() => {
    // 依存配列を適切に設定
    fetchArticle(articleId).then(setArticle)
  }, [articleId])  // articleIdが変更された時のみ実行
  
  return <div>{article?.title}</div>
}
```

## パフォーマンス最適化

### React.memo活用
```tsx
// 不要な再レンダリングを防ぐ
export const ArticleCard = React.memo(({ article }: ArticleCardProps) => {
  return (
    <article>
      <h2>{article.title}</h2>
    </article>
  )
})
```

### 動的インポート
```tsx
// 重いコンポーネントは動的インポート
const HeavyChart = dynamic(() => import("./HeavyChart"), {
  loading: () => <div>読み込み中...</div>
})
```
